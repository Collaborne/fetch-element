<!--
@license
Copyright (c) 2015 Glenn Vandeuren. All rights reserved.
-->
<link rel="import" href="../polymer/polymer.html">
<script>
  if (!Promise) {
    document.write('<script src="../es6-promise/dist/es6-promise.js"><\\/script>');
  }
  if (!fetch) {
    document.write('<script src="../fetch/fetch.js"><\\/script>');
  }
</script>

<!--
An element wrapping [Fetch](https://github.com/github/fetch).

Example:

    <fetch-element></fetch-element>

@demo demo/index.html
-->

<script>

  Polymer({

    is: 'fetch-element',

    properties: {

      url: String,

      headers: Object,

      /*
      * “same-origin” only succeeds for requests for assets on the same origin, all other requests will reject.
      * “cors” will allow requests for assets on the same-origin and other origins which return the appropriate CORs headers.
      * “cors-with-forced-preflight” will always perform a preflight check before making the actual request.
      * “no-cors” is intended to make requests to other origins that do not have CORS headers and result in an opaque response, but as stated, this isn’t possible in the window global scope at the moment.
      */
      mode: {
        type: String,
        value: 'cors'
      },

      /**
      * Set method to 'post' for writing data to JSON.
      */
      method: String,

      /**
      * the object to add
      */
      body: {
        type: Object,
        value: undefined
      },

      type: {
        type: String
      },

      data: {
        type: Object,
        notify: true
      },

      loading: {
        type: Boolean,
        readOnly: true,
        reflectToAttribute: true
      },

      auto: {
        type: Boolean,
        reflectToAttribute: true
      },

      error: {
        type: Object,
        notify: true
      },

      log: {
        type: Boolean,
        value: false
      },

      /**
      * The function you wanna run in the stream, for resolving data.
      */
      streamFunction: {
        type: Function
      },

      noProgress: {
        type: Boolean,
        value: false
      }

    },

    observers: [
      'fetch(body, headers, auto)'
    ],

    // Element Lifecycle

    attached: function() {
      if (this.method !== 'post' && this.auto) {
        this.fetch();
      }
    },

    // Element Behavior

    fetch: function () {
      this.params = {mode: this.mode};
      this.params.headers = this.headers;

      if (this.method === 'post') {
        this.params.method = this.method;
        this.params.body = this.body;
      }

      fetch(this.url, this.params)
        .then(this._status.bind(this))
        .then(this._json.bind(this))
        .then(this._responseData.bind(this))
        .catch(this._errorHandler.bind(this));
    },

    stream : function (url, decoder) {
      fetch(this.url)
        .then(this._handleProgress.bind(this))
        .then(this._status.bind(this))
        // .then(this._handleResponse.bind(this))
        .then(this._json.bind(this))
        .then(this._responseData.bind(this))
      .catch(function(err) {console.log(err.message);});
    },

    _handleProgress: function (response) {
      // this.fire('handle-response', response);
      var reader = response.body.getReader();
      if (!this.noProgress) {
        this._checkProgress(reader, response);
        return this._checkProgress(reader, response);
      }
    },

    _checkProgress: function(reader, response) {
      return reader.read()
        .then(function(result) {
          if (!result.done) {
            this._setLoading(true);
            this.fire('progress', 'loading');

            return this._checkProgress(reader, response);
          }

          if (result.done) {
            this._setLoading(false);
            this.fire('loaded', response);
            return response;
          }
      }.bind(this));
    },

    _handleResponse: function (response) {
      if (this.type) {
        console.log(response);
        return Promise.resolve(response[this.type]());
      }
      return Promise.resolve(response);
    },

    _status: function (response) {
      if (response.status >= 200 && response.status < 300) {
        return Promise.resolve(response);
      } else {
        return Promise.reject(new Error(response.statusText));
      }
    },

    _json: function (response) {
      return response.json();
    },

    _responseData: function (response) {
      this.fire('response', response);
      return this.data = response;
    },

    _errorHandler: function(error) {
      var err = error.message?error.message:error;
      if (this.log) {
        console.log('Request failed', err);
      }
      return this.error = err;
    }

  });

</script>
